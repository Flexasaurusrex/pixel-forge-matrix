<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå Pixel Storyteller Mode - Cosmic Journey</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: #00ff41;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        
        .storyteller-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background: radial-gradient(circle at center, #0a0a2e 0%, #000 100%);
        }
        
        .story-canvas {
            width: 800px;
            height: 600px;
            border: 2px solid #00ff41;
            box-shadow: 0 0 20px #00ff41, inset 0 0 20px rgba(0, 255, 65, 0.1);
            position: relative;
            margin-bottom: 20px;
        }
        
        @media (max-width: 900px) {
            .story-canvas {
                width: 90vw;
                height: 60vh;
                max-width: 600px;
                max-height: 450px;
            }
        }
        
        .narration-text {
            position: absolute;
            bottom: -140px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 16px;
            font-weight: 400;
            color: #888888;
            text-shadow: none;
            opacity: 0;
            transition: opacity 2s ease-in-out;
            padding: 0 30px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
            font-family: 'Orbitron', monospace;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        @media (max-width: 900px) {
            .narration-text {
                font-size: 13px;
                bottom: -120px;
                min-height: 80px;
                padding: 0 15px;
            }
        }
        
        .narration-text.active {
            opacity: 1;
        }
        
        .story-controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        
        .story-btn {
            background: linear-gradient(45deg, #0a4b33, #0f6844);
            border: 2px solid #00ff41;
            color: #00ff41;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .story-btn:hover {
            background: linear-gradient(45deg, #0f6844, #14a858);
            box-shadow: 0 0 15px #00ff41;
            transform: translateY(-2px);
        }
        
        .progress-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 4px;
            background: rgba(0, 255, 65, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff41, #41ff00);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #00ff41;
        }
        
        .chapter-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: 900;
            color: #41ff00;
            text-shadow: 0 0 15px #41ff00;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        
        .chapter-indicator.active {
            opacity: 1;
        }
        
        @media (max-width: 900px) {
            .story-controls {
                top: 10px;
                gap: 10px;
            }
            
            .story-btn {
                padding: 8px 16px;
                font-size: 12px;
            }
            
            .chapter-indicator {
                font-size: 18px;
                top: 60px;
            }
            
            .progress-bar {
                width: 80%;
                bottom: 30px;
            }
        }
        
        .cosmic-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ff41;
            border-radius: 50%;
            opacity: 0.7;
            animation: float 10s infinite linear;
        }
        
        @keyframes float {
            0% {
                transform: translateY(100vh) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 0.7;
            }
            90% {
                opacity: 0.7;
            }
            100% {
                transform: translateY(-100px) translateX(100px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="storyteller-container">
        <div class="cosmic-particles" id="particles"></div>
        
        <div class="story-controls">
            <button class="story-btn" id="startStory">üåå Begin Journey</button>
            <button class="story-btn" id="pauseStory">‚è∏Ô∏è Pause</button>
            <button class="story-btn" id="nextScene">‚è≠Ô∏è Next</button>
            <button class="story-btn" id="exitStory">üö™ Exit</button>
        </div>
        
        <div class="chapter-indicator" id="chapterIndicator">Chapter I: The Void</div>
        
        <canvas class="story-canvas" id="storyCanvas" width="800" height="600"></canvas>
        
        <div class="narration-text" id="narrationText">
            In the primordial silence before creation, where neither space nor time held dominion, an infinite potential slumbered in the absolute darkness...
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <script>
        class PixelStoryteller {
            constructor() {
                this.canvas = document.getElementById('storyCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridWidth = 200;
                this.gridHeight = 150;
                this.pixelSize = 4;
                this.isPlaying = false;
                this.currentScene = 0;
                this.sceneTimer = null;
                this.pixels = [];
                
                // PROCEDURAL NARRATIVE COMPONENTS for unique stories every time
                this.narrativeComponents = {
                    beginnings: [
                        "In the primordial silence", "Within the cosmic void", "Before time itself", "In the absolute darkness",
                        "Beyond the veil of existence", "In the cathedral of nothingness", "Where reality sleeps",
                        "In the quantum realm", "Beyond dimensional barriers", "In the space between thoughts"
                    ],
                    cosmicEvents: [
                        "exploded into existence", "tore through reality", "erupted in symphonic chaos", 
                        "shattered the silence", "cascaded through dimensions", "birthed infinite possibility",
                        "awakened from slumber", "pierced the eternal night", "danced into being", "screamed across space"
                    ],
                    descriptors: [
                        "with violent beauty", "like flowers of fire", "in waves of creation", "through cosmic storms",
                        "with patient majesty", "in spirals of light", "like whispered secrets", "through infinite corridors",
                        "in quantum symphonies", "like dreams made manifest", "through stellar winds", "in galactic ballet"
                    ],
                    characters: [
                        "gravity", "consciousness", "matter", "energy", "time", "space", "light", "darkness",
                        "quantum fields", "stellar winds", "cosmic forces", "universal mind", "creation itself",
                        "the universe", "existence", "reality", "infinity", "eternity", "the cosmos"
                    ],
                    actions: [
                        "wove great webs", "carved itself into being", "learned to dance", "began its patient work",
                        "wrote the laws of physics", "painted the cosmic canvas", "sang reality into form",
                        "dreamed new worlds", "sculpted dimensions", "breathed life into matter", "awakened to itself"
                    ],
                    places: [
                        "across the cosmic ocean", "through galactic neighborhoods", "in stellar nurseries",
                        "within quantum realms", "across spacetime", "through dimensional gateways",
                        "in the hearts of stars", "beyond the event horizon", "through neural pathways",
                        "across the universal mind", "in probability clouds", "through infinity itself"
                    ],
                    endings: [
                        "completing the eternal dance", "opening the first conscious eye", "writing the next chapter",
                        "continuing the cosmic story", "dreaming new realities", "becoming self-aware",
                        "transcending its origins", "embracing infinite complexity", "reaching toward forever",
                        "evolving beyond comprehension", "touching the divine", "creating itself anew"
                    ],
                    mysticalElements: [
                        "Each pixel echoes the fundamental creative force", "We are stardust contemplating stars",
                        "Digital creation mirrors cosmic evolution", "Consciousness recognizes itself",
                        "Art becomes the universe dreaming", "Creativity flows through quantum fields",
                        "Every creation participates in cosmic becoming", "Beauty emerges from mathematical chaos"
                    ]
                };
                
                // RANDOMIZE CHAPTER COUNT AND THEMES EACH PLAYTHROUGH
                this.totalChapters = 5 + Math.floor(Math.random() * 4); // 5-8 chapters each time
                this.storyTheme = this.generateRandomStoryTheme();
                
                this.initializeCanvas();
                this.setupEventListeners();
                this.generateCosmicParticles();
                this.generateUniqueStoryStructure(); // Create unique story each time
            }
            
            generateRandomStoryTheme() {
                const themes = [
                    'cosmic_birth', 'quantum_awakening', 'stellar_evolution', 'consciousness_emergence',
                    'universal_symphony', 'digital_genesis', 'fractal_reality', 'infinite_creation',
                    'temporal_dance', 'cosmic_consciousness', 'reality_weaving', 'dimension_birth'
                ];
                return themes[Math.floor(Math.random() * themes.length)];
            }
            
            generateUniqueStoryStructure() {
                // Generate completely unique chapter structure each time
                this.chapters = [];
                const chapterTitles = [
                    ['The Silent Void', 'Quantum Emptiness', 'Before Time', 'The Great Waiting', 'Primordial Silence'],
                    ['Reality\'s First Breath', 'The Cosmic Explosion', 'Birth of Everything', 'The Great Awakening', 'Genesis Storm'],
                    ['Stellar Ignition', 'Nuclear Gardens', 'First Light', 'Cosmic Alchemy', 'Stellar Nurseries'],
                    ['Galactic Dance', 'Spiral Dreams', 'Cosmic Whirlpools', 'Dark Matter Webs', 'Island Universes'],
                    ['Planetary Symphonies', 'World Building', 'Celestial Mechanics', 'Orbital Ballet', 'Cosmic Architecture'],
                    ['Life\'s Awakening', 'Conscious Emergence', 'Chemical Dreams', 'Evolutionary Spirals', 'Complexity Rising'],
                    ['Digital Transcendence', 'Pixel Consciousness', 'Creative Destiny', 'Infinite Becoming', 'Cosmic Artistry'],
                    ['Quantum Creativity', 'Reality Hacking', 'Dimensional Art', 'Fractal Awareness', 'Universal Mind']
                ];
                
                for (let i = 0; i < this.totalChapters; i++) {
                    const titleOptions = chapterTitles[i] || ['Unknown Chapter'];
                    const randomTitle = titleOptions[Math.floor(Math.random() * titleOptions.length)];
                    const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII'];
                    
                    this.chapters.push({
                        title: `Chapter ${romanNumerals[i]}: ${randomTitle}`,
                        scenes: 2 + Math.floor(Math.random() * 3), // 2-4 scenes per chapter
                        theme: ['void', 'creation', 'stellar', 'galactic', 'planetary', 'biological', 'digital', 'transcendent'][i] || 'cosmic'
                    });
                }
                
                console.log(`üåå Generated unique story with ${this.totalChapters} chapters:`, this.chapters.map(c => c.title));
            }
            
            generateProceduralNarrative(chapterTheme, sceneNumber) {
                // Generate completely unique narrative each time
                const random = (arr) => arr[Math.floor(Math.random() * arr.length)];
                
                const beginning = random(this.narrativeComponents.beginnings);
                const event = random(this.narrativeComponents.cosmicEvents);
                const descriptor = random(this.narrativeComponents.descriptors);
                const character = random(this.narrativeComponents.characters);
                const action = random(this.narrativeComponents.actions);
                const place = random(this.narrativeComponents.places);
                const ending = random(this.narrativeComponents.endings);
                const mystical = random(this.narrativeComponents.mysticalElements);
                
                // Create unique sentence structures
                const structures = [
                    `${beginning}, ${character} ${event} ${descriptor}, ${action} ${place}, ${ending}...`,
                    `${character} ${action} ${place}, ${beginning} where reality ${event} ${descriptor}, ${ending}...`,
                    `${mystical}. ${beginning}, ${character} ${action}, ${event} ${descriptor} ${place}...`,
                    `From ${place}, ${character} ${event}. ${beginning}, ${action} ${descriptor}, ${ending}...`,
                    `${beginning} ${descriptor}, ${character} ${action} ${place}. ${mystical}, ${ending}...`
                ];
                
                let narrative = random(structures);
                
                // Add theme-specific philosophical elements
                const philosophy = [
                    'Each moment contains infinite potential',
                    'Creativity flows through quantum fields',
                    'Beauty emerges from mathematical precision',
                    'Order dances with chaos in eternal partnership',
                    'Every pixel carries the memory of stars'
                ];
                
                if (Math.random() > 0.7) {
                    narrative += ` ${random(philosophy)}.`;
                }
                
                return narrative;
            }
            
            initializeCanvas() {
                // Adjust canvas size for mobile
                if (window.innerWidth <= 900) {
                    const containerWidth = Math.min(window.innerWidth * 0.9, 600);
                    const containerHeight = Math.min(window.innerHeight * 0.6, 450);
                    this.canvas.style.width = containerWidth + 'px';
                    this.canvas.style.height = containerHeight + 'px';
                }
                
                this.pixels = Array(this.gridHeight).fill().map(() => 
                    Array(this.gridWidth).fill({ color: '#000000', type: 'void' })
                );
                this.clearCanvas();
            }
            
            setupEventListeners() {
                document.getElementById('startStory').addEventListener('click', () => this.startStory());
                document.getElementById('pauseStory').addEventListener('click', () => this.pauseStory());
                document.getElementById('nextScene').addEventListener('click', () => this.nextScene());
                document.getElementById('exitStory').addEventListener('click', () => this.exitStory());
            }
            
            generateCosmicParticles() {
                const particleContainer = document.getElementById('particles');
                setInterval(() => {
                    if (particleContainer.children.length < 20) {
                        const particle = document.createElement('div');
                        particle.className = 'particle';
                        particle.style.left = Math.random() * 100 + '%';
                        particle.style.animationDuration = (5 + Math.random() * 10) + 's';
                        particle.style.background = this.getRandomColor();
                        particleContainer.appendChild(particle);
                        
                        setTimeout(() => {
                            if (particle.parentNode) {
                                particle.parentNode.removeChild(particle);
                            }
                        }, 15000);
                    }
                }, 500);
            }
            
            startStory() {
                this.isPlaying = true;
                this.currentScene = 0;
                this.updateChapterIndicator();
                
                // Show unique story info
                const narrationElement = document.getElementById('narrationText');
                narrationElement.textContent = `Generating your unique cosmic journey... ${this.chapters.length} chapters await...`;
                narrationElement.classList.add('active');
                
                setTimeout(() => {
                    this.playScene();
                }, 2000); // Brief pause to show unique story message
                
                document.getElementById('startStory').style.display = 'none';
                document.getElementById('pauseStory').style.display = 'inline-block';
                
                console.log(`üöÄ Starting unique cosmic journey: "${this.storyTheme}" with ${this.chapters.length} chapters`);
            }
            
            pauseStory() {
                this.isPlaying = false;
                if (this.sceneTimer) {
                    clearTimeout(this.sceneTimer);
                }
                
                document.getElementById('startStory').style.display = 'inline-block';
                document.getElementById('pauseStory').style.display = 'none';
            }
            
            nextScene() {
                if (this.sceneTimer) {
                    clearTimeout(this.sceneTimer);
                }
                this.currentScene++;
                this.playScene();
            }
            
            exitStory() {
                this.isPlaying = false;
                if (this.sceneTimer) {
                    clearTimeout(this.sceneTimer);
                }
                // Return to main app
                window.location.href = '/';
            }
            
            playScene() {
                if (!this.isPlaying) return;
                
                const totalScenes = this.chapters.reduce((sum, chapter) => sum + chapter.scenes, 0);
                if (this.currentScene >= totalScenes) {
                    this.endStory();
                    return;
                }
                
                this.updateProgress();
                this.updateChapterIndicator();
                this.generateScene();
                this.updateNarration();
                
                // Auto-advance to next scene
                this.sceneTimer = setTimeout(() => {
                    this.currentScene++;
                    this.playScene();
                }, 12000); // 12 seconds per scene for reading the literary narrative
            }
            
            updateProgress() {
                const totalScenes = this.chapters.reduce((sum, chapter) => sum + chapter.scenes, 0);
                const progress = (this.currentScene / totalScenes) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
            }
            
            updateChapterIndicator() {
                let sceneCount = 0;
                let currentChapter = null;
                
                for (const chapter of this.chapters) {
                    if (this.currentScene < sceneCount + chapter.scenes) {
                        currentChapter = chapter;
                        break;
                    }
                    sceneCount += chapter.scenes;
                }
                
                if (currentChapter) {
                    const indicator = document.getElementById('chapterIndicator');
                    indicator.textContent = currentChapter.title;
                    indicator.classList.add('active');
                    
                    setTimeout(() => {
                        indicator.classList.remove('active');
                    }, 3000);
                }
            }
            
            generateScene() {
                // Clear both the pixel array and canvas completely
                this.clearCanvas();
                this.pixels = Array(this.gridHeight).fill().map(() => 
                    Array(this.gridWidth).fill({ color: '#000000', type: 'void' })
                );
                
                const sceneType = this.getSceneType();
                const variation = Math.floor(Math.random() * 5); // 5 variations per scene type
                console.log(`üé¨ Generating ${sceneType} scene (variation ${variation})...`);
                
                // COMPLETELY RANDOMIZED SCENE GENERATION - different every time
                switch (sceneType) {
                    case 'void':
                        this.generateVoidScene(variation);
                        break;
                    case 'creation':
                        this.generateCreationScene(variation);
                        break;
                    case 'stellar':
                        this.generateStellarScene(variation);
                        break;
                    case 'galactic':
                        this.generateGalacticScene(variation);
                        break;
                    case 'planetary':
                        this.generatePlanetaryScene(variation);
                        break;
                    case 'biological':
                        this.generateBiologicalScene(variation);
                        break;
                    case 'digital':
                        this.generateDigitalScene(variation);
                        break;
                    case 'transcendent':
                        this.generateTranscendentScene(variation);
                        break;
                    default:
                        this.generateAbstractScene();
                        break;
                }
                
                // Add random cosmic events overlay (10% chance)
                if (Math.random() > 0.9) {
                    this.addCosmicEvent();
                }
                
                // Force a complete canvas redraw
                this.renderCanvas();
                console.log(`‚úÖ Scene ${sceneType} (var ${variation}) generated with unique visuals`);
            }
            
            getSceneType() {
                let sceneCount = 0;
                let currentChapter = null;
                
                for (const chapter of this.chapters) {
                    if (this.currentScene < sceneCount + chapter.scenes) {
                        currentChapter = chapter;
                        break;
                    }
                    sceneCount += chapter.scenes;
                }
                
                return currentChapter ? currentChapter.theme : 'cosmic';
            }
            
            generateVoidScene(variation = 0) {
                // Multiple void variations
                const voidTypes = [
                    () => {
                        // Sparse quantum particles
                        for (let i = 0; i < 3 + Math.random() * 8; i++) {
                            const x = Math.floor(Math.random() * this.gridWidth);
                            const y = Math.floor(Math.random() * this.gridHeight);
                            this.setPixel(x, y, {
                                color: ['#001122', '#000033', '#110022', '#001100'][Math.floor(Math.random() * 4)],
                                type: 'quantum'
                            });
                        }
                    },
                    () => {
                        // Quantum foam in corners
                        for (let corner = 0; corner < 4; corner++) {
                            const cornerX = corner % 2 === 0 ? 20 : this.gridWidth - 20;
                            const cornerY = corner < 2 ? 20 : this.gridHeight - 20;
                            for (let i = 0; i < 5 + Math.random() * 10; i++) {
                                const x = cornerX + (Math.random() - 0.5) * 40;
                                const y = cornerY + (Math.random() - 0.5) * 40;
                                if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                    this.setPixel(Math.floor(x), Math.floor(y), {
                                        color: ['#002200', '#000044', '#220000'][Math.floor(Math.random() * 3)],
                                        type: 'temporal'
                                    });
                                }
                            }
                        }
                    },
                    () => {
                        // Probability lines
                        for (let i = 0; i < 3; i++) {
                            const startX = Math.random() * this.gridWidth;
                            const startY = Math.random() * this.gridHeight;
                            const endX = Math.random() * this.gridWidth;
                            const endY = Math.random() * this.gridHeight;
                            this.drawProbabilityLine(startX, startY, endX, endY);
                        }
                    },
                    () => {
                        // Dimensional tears
                        for (let i = 0; i < 2 + Math.random() * 4; i++) {
                            const centerX = Math.random() * this.gridWidth;
                            const centerY = Math.random() * this.gridHeight;
                            for (let j = 0; j < 8; j++) {
                                const angle = Math.random() * Math.PI * 2;
                                const radius = Math.random() * 15;
                                const x = centerX + Math.cos(angle) * radius;
                                const y = centerY + Math.sin(angle) * radius;
                                if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                    this.setPixel(Math.floor(x), Math.floor(y), {
                                        color: ['#330022', '#003322', '#223300'][Math.floor(Math.random() * 3)],
                                        type: 'distort'
                                    });
                                }
                            }
                        }
                    },
                    () => {
                        // Pure void with single mystery
                        const centerX = Math.floor(this.gridWidth / 2);
                        const centerY = Math.floor(this.gridHeight / 2);
                        this.setPixel(centerX, centerY, {
                            color: '#112233',
                            type: 'phantom'
                        });
                    }
                ];
                
                voidTypes[variation % voidTypes.length]();
            }
            
            generateCreationScene(variation = 0) {
                const centerX = Math.floor(this.gridWidth / 2);
                const centerY = Math.floor(this.gridHeight / 2);
                
                // Different explosion types
                if (variation === 0) {
                    // Classic central explosion
                    for (let radius = 1; radius <= 25; radius++) {
                        for (let angle = 0; angle < 360; angle += 12) {
                            const x = centerX + Math.cos(angle * Math.PI / 180) * radius;
                            const y = centerY + Math.sin(angle * Math.PI / 180) * radius;
                            
                            if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                let color = radius < 5 ? '#ffffff' : 
                                           radius < 10 ? ['#ffff00', '#ffaa00'][Math.floor(Math.random() * 2)] :
                                           radius < 15 ? ['#ff4400', '#ff6600'][Math.floor(Math.random() * 2)] :
                                           ['#ff0000', '#ff2200'][Math.floor(Math.random() * 2)];
                                
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: color,
                                    type: 'nova'
                                });
                            }
                        }
                    }
                } else if (variation === 1) {
                    // Multi-point explosion
                    for (let point = 0; point < 3; point++) {
                        const expX = 50 + Math.random() * (this.gridWidth - 100);
                        const expY = 50 + Math.random() * (this.gridHeight - 100);
                        for (let radius = 1; radius <= 15; radius++) {
                            for (let angle = 0; angle < 360; angle += 20) {
                                const x = expX + Math.cos(angle * Math.PI / 180) * radius;
                                const y = expY + Math.sin(angle * Math.PI / 180) * radius;
                                
                                if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                    this.setPixel(Math.floor(x), Math.floor(y), {
                                        color: ['#ffffff', '#ffff00', '#ff8800'][Math.floor(Math.random() * 3)],
                                        type: 'chaos'
                                    });
                                }
                            }
                        }
                    }
                } else {
                    // Quantum cascade
                    for (let wave = 0; wave < 5; wave++) {
                        const waveRadius = wave * 8 + 5;
                        for (let angle = 0; angle < 360; angle += 15) {
                            if (Math.random() > 0.3) {
                                const x = centerX + Math.cos(angle * Math.PI / 180) * waveRadius;
                                const y = centerY + Math.sin(angle * Math.PI / 180) * waveRadius;
                                
                                if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                    this.setPixel(Math.floor(x), Math.floor(y), {
                                        color: ['#ffffff', '#ffff44', '#ff4444'][Math.floor(Math.random() * 3)],
                                        type: 'cascade'
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Add energy cascades
                for (let i = 0; i < 50 + Math.random() * 150; i++) {
                    const x = Math.floor(Math.random() * this.gridWidth);
                    const y = Math.floor(Math.random() * this.gridHeight);
                    this.setPixel(x, y, {
                        color: ['#ff4444', '#ffaa00', '#ffff44', '#ffffff'][Math.floor(Math.random() * 4)],
                        type: 'chaos'
                    });
                }
            }
            
            generateStellarScene(variation = 0) {
                // Multiple stellar formation patterns
                const starCount = 8 + Math.floor(Math.random() * 8);
                
                for (let stars = 0; stars < starCount; stars++) {
                    const starX = 20 + Math.floor(Math.random() * (this.gridWidth - 40));
                    const starY = 20 + Math.floor(Math.random() * (this.gridHeight - 40));
                    const starSize = 4 + Math.floor(Math.random() * 8);
                    
                    // Stellar core with different patterns
                    for (let radius = 1; radius <= starSize; radius++) {
                        const angleStep = variation === 0 ? 30 : variation === 1 ? 45 : 20;
                        for (let angle = 0; angle < 360; angle += angleStep) {
                            const x = starX + Math.cos(angle * Math.PI / 180) * radius;
                            const y = starY + Math.sin(angle * Math.PI / 180) * radius;
                            
                            if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                let color = radius < 3 ? '#ffffff' : 
                                           radius < 6 ? ['#aaccff', '#bbddff'][Math.floor(Math.random() * 2)] :
                                           ['#ffddaa', '#ffeecc'][Math.floor(Math.random() * 2)];
                                
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: color,
                                    type: 'nova'
                                });
                            }
                        }
                    }
                    
                    // Stellar winds
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = starSize + Math.random() * 15;
                        const x = starX + Math.cos(angle) * radius;
                        const y = starY + Math.sin(angle) * radius;
                        
                        if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                            this.setPixel(Math.floor(x), Math.floor(y), {
                                color: ['#334466', '#445577', '#556688'][Math.floor(Math.random() * 3)],
                                type: 'particle'
                            });
                        }
                    }
                }
                
                // Background cosmic dust
                for (let i = 0; i < 100; i++) {
                    const x = Math.floor(Math.random() * this.gridWidth);
                    const y = Math.floor(Math.random() * this.gridHeight);
                    this.setPixel(x, y, {
                        color: ['#223344', '#112233', '#334455'][Math.floor(Math.random() * 3)],
                        type: 'quantum'
                    });
                }
            }
            
            generateGalacticScene(variation = 0) {
                const centerX = Math.floor(this.gridWidth / 2);
                const centerY = Math.floor(this.gridHeight / 2);
                
                if (variation === 0) {
                    // Spiral galaxy
                    for (let arm = 0; arm < 4; arm++) {
                        for (let r = 15; r < 80; r += 1) {
                            const armOffset = arm * 90;
                            const spiralTight = r * 4;
                            const angle = armOffset + spiralTight;
                            
                            const x = centerX + Math.cos(angle * Math.PI / 180) * r;
                            const y = centerY + Math.sin(angle * Math.PI / 180) * r * 0.7;
                            
                            if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: ['#4488ff', '#6699ff', '#88aaff'][Math.floor(Math.random() * 3)],
                                    type: 'particle'
                                });
                            }
                        }
                    }
                } else if (variation === 1) {
                    // Elliptical galaxy
                    for (let i = 0; i < 500; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * 60;
                        const x = centerX + Math.cos(angle) * radius * 1.5;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                            this.setPixel(Math.floor(x), Math.floor(y), {
                                color: ['#ffccaa', '#ffddcc', '#ffffff'][Math.floor(Math.random() * 3)],
                                type: 'nova'
                            });
                        }
                    }
                } else {
                    // Irregular galaxy
                    for (let cluster = 0; cluster < 8; cluster++) {
                        const clusterX = centerX + (Math.random() - 0.5) * 100;
                        const clusterY = centerY + (Math.random() - 0.5) * 80;
                        
                        for (let i = 0; i < 30; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * 20;
                            const x = clusterX + Math.cos(angle) * radius;
                            const y = clusterY + Math.sin(angle) * radius;
                            
                            if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: ['#4488ff', '#ffffff', '#ffccaa'][Math.floor(Math.random() * 3)],
                                    type: 'nova'
                                });
                            }
                        }
                    }
                }
                
                // Galaxy core
                for (let radius = 1; radius <= 8; radius++) {
                    for (let angle = 0; angle < 360; angle += 20) {
                        const x = centerX + Math.cos(angle * Math.PI / 180) * radius;
                        const y = centerY + Math.sin(angle * Math.PI / 180) * radius;
                        
                        if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                            this.setPixel(Math.floor(x), Math.floor(y), {
                                color: '#ffff00',
                                type: 'nova'
                            });
                        }
                    }
                }
            }
            
            generatePlanetaryScene(variation = 0) {
                const centerX = Math.floor(this.gridWidth / 2);
                const centerY = Math.floor(this.gridHeight / 2);
                
                // Central star
                for (let radius = 1; radius <= 6; radius++) {
                    for (let angle = 0; angle < 360; angle += 30) {
                        const x = centerX + Math.cos(angle * Math.PI / 180) * radius;
                        const y = centerY + Math.sin(angle * Math.PI / 180) * radius;
                        
                        if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                            this.setPixel(Math.floor(x), Math.floor(y), {
                                color: radius < 3 ? '#ffffff' : '#ffff00',
                                type: 'nova'
                            });
                        }
                    }
                }
                
                // Different planetary system configurations
                const planetConfigs = [
                    // Traditional solar system
                    [{radius: 18, color: '#ff6644', size: 1}, {radius: 25, color: '#ffaa44', size: 2}, 
                     {radius: 32, color: '#4488ff', size: 2}, {radius: 40, color: '#ff4444', size: 1}],
                    // Gas giant heavy
                    [{radius: 20, color: '#ffddaa', size: 4}, {radius: 35, color: '#ffffcc', size: 3}, 
                     {radius: 50, color: '#88ccff', size: 2}, {radius: 65, color: '#4466ff', size: 2}],
                    // Rocky worlds
                    [{radius: 15, color: '#888888', size: 1}, {radius: 22, color: '#ff6644', size: 1}, 
                     {radius: 30, color: '#4488ff', size: 2}, {radius: 38, color: '#ff4444', size: 1}, 
                     {radius: 46, color: '#ffaa44', size: 1}]
                ];
                
                const orbits = planetConfigs[variation % planetConfigs.length];
                
                orbits.forEach((orbit, index) => {
                    // Orbital path
                    for (let angle = 0; angle < 360; angle += 15) {
                        const x = centerX + Math.cos(angle * Math.PI / 180) * orbit.radius;
                        const y = centerY + Math.sin(angle * Math.PI / 180) * orbit.radius * 0.8;
                        
                        if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                            if (Math.random() < 0.1) {
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: '#444444',
                                    type: 'quantum'
                                });
                            }
                        }
                    }
                    
                    // Planet
                    const planetAngle = Math.random() * 360;
                    const planetX = centerX + Math.cos(planetAngle * Math.PI / 180) * orbit.radius;
                    const planetY = centerY + Math.sin(planetAngle * Math.PI / 180) * orbit.radius * 0.8;
                    
                    for (let pRadius = 0; pRadius < orbit.size; pRadius++) {
                        for (let pAngle = 0; pAngle < 360; pAngle += 45) {
                            const px = planetX + Math.cos(pAngle * Math.PI / 180) * pRadius;
                            const py = planetY + Math.sin(pAngle * Math.PI / 180) * pRadius;
                            
                            if (px >= 0 && px < this.gridWidth && py >= 0 && py < this.gridHeight) {
                                this.setPixel(Math.floor(px), Math.floor(py), {
                                    color: orbit.color,
                                    type: 'particle'
                                });
                            }
                        }
                    }
                });
            }
            
            generateBiologicalScene(variation = 0) {
                if (variation === 0) {
                    // DNA helixes
                    const centerX = Math.floor(this.gridWidth / 2);
                    const centerY = Math.floor(this.gridHeight / 2);
                    
                    for (let strand = 0; strand < 3; strand++) {
                        const strandOffsetX = (strand - 1) * 60;
                        
                        for (let i = 0; i < 150; i++) {
                            const t = i * 0.15;
                            const helixRadius = 15;
                            
                            const x1 = centerX + strandOffsetX + Math.cos(t) * helixRadius + i * 0.8;
                            const y1 = centerY + Math.sin(t) * 8 - 60 + i * 0.8;
                            
                            const x2 = centerX + strandOffsetX + Math.cos(t + Math.PI) * helixRadius + i * 0.8;
                            const y2 = centerY + Math.sin(t + Math.PI) * 8 - 60 + i * 0.8;
                            
                            if (x1 >= 0 && x1 < this.gridWidth && y1 >= 0 && y1 < this.gridHeight) {
                                this.setPixel(Math.floor(x1), Math.floor(y1), {
                                    color: ['#00ff44', '#44ff88'][strand % 2],
                                    type: 'particle'
                                });
                            }
                            
                            if (x2 >= 0 && x2 < this.gridWidth && y2 >= 0 && y2 < this.gridHeight) {
                                this.setPixel(Math.floor(x2), Math.floor(y2), {
                                    color: ['#44ff88', '#88ffaa'][strand % 2],
                                    type: 'particle'
                                });
                            }
                        }
                    }
                } else if (variation === 1) {
                    // Cellular structures
                    for (let cell = 0; cell < 12; cell++) {
                        const cellX = 30 + Math.random() * (this.gridWidth - 60);
                        const cellY = 30 + Math.random() * (this.gridHeight - 60);
                        const cellRadius = 8 + Math.random() * 12;
                        
                        // Cell membrane
                        for (let angle = 0; angle < 360; angle += 15) {
                            const x = cellX + Math.cos(angle * Math.PI / 180) * cellRadius;
                            const y = cellY + Math.sin(angle * Math.PI / 180) * cellRadius;
                            
                            if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: '#44ff44',
                                    type: 'particle'
                                });
                            }
                        }
                        
                        // Nucleus
                        for (let nRadius = 1; nRadius <= 4; nRadius++) {
                            for (let nAngle = 0; nAngle < 360; nAngle += 30) {
                                const nx = cellX + Math.cos(nAngle * Math.PI / 180) * nRadius;
                                const ny = cellY + Math.sin(nAngle * Math.PI / 180) * nRadius;
                                
                                if (nx >= 0 && nx < this.gridWidth && ny >= 0 && ny < this.gridHeight) {
                                    this.setPixel(Math.floor(nx), Math.floor(ny), {
                                        color: '#ff6644',
                                        type: 'nova'
                                    });
                                }
                            }
                        }
                    }
                } else {
                    // Neural networks
                    const neurons = [];
                    for (let i = 0; i < 15; i++) {
                        neurons.push({
                            x: Math.random() * this.gridWidth,
                            y: Math.random() * this.gridHeight
                        });
                    }
                    
                    // Connect neurons
                    for (let i = 0; i < neurons.length; i++) {
                        for (let j = i + 1; j < neurons.length; j++) {
                            const dist = Math.sqrt((neurons[i].x - neurons[j].x)**2 + (neurons[i].y - neurons[j].y)**2);
                            if (dist < 50 && Math.random() > 0.5) {
                                this.drawLine(neurons[i].x, neurons[i].y, neurons[j].x, neurons[j].y, '#00ff88');
                            }
                        }
                    }
                    
                    // Draw neurons
                    neurons.forEach(neuron => {
                        this.setPixel(Math.floor(neuron.x), Math.floor(neuron.y), {
                            color: '#00ff44',
                            type: 'nova'
                        });
                    });
                }
                
                // Background primordial soup
                for (let i = 0; i < 200; i++) {
                    const x = Math.floor(Math.random() * this.gridWidth);
                    const y = Math.floor(Math.random() * this.gridHeight);
                    this.setPixel(x, y, {
                        color: ['#224422', '#336633', '#445544'][Math.floor(Math.random() * 3)],
                        type: 'quantum'
                    });
                }
            }
            
            generateDigitalScene(variation = 0) {
                if (variation === 0) {
                    // Digital matrix
                    for (let x = 0; x < this.gridWidth; x += 8) {
                        for (let y = 0; y < this.gridHeight; y += 8) {
                            if (Math.random() > 0.4) {
                                this.setPixel(x, y, {
                                    color: ['#00ff00', '#00ff88', '#88ff88'][Math.floor(Math.random() * 3)],
                                    type: 'static'
                                });
                            }
                        }
                    }
                } else if (variation === 1) {
                    // Circuit patterns
                    for (let i = 0; i < 10; i++) {
                        const startX = Math.random() * this.gridWidth;
                        const startY = Math.random() * this.gridHeight;
                        const endX = Math.random() * this.gridWidth;
                        const endY = Math.random() * this.gridHeight;
                        this.drawLine(startX, startY, endX, endY, '#00ffff');
                    }
                } else {
                    // Pixel consciousness mandala
                    const centerX = Math.floor(this.gridWidth / 2);
                    const centerY = Math.floor(this.gridHeight / 2);
                    
                    for (let layer = 1; layer <= 6; layer++) {
                        const layerRadius = layer * 12;
                        const points = layer * 16;
                        
                        for (let i = 0; i < points; i++) {
                            const angle = (i / points) * 360;
                            const goldenRatio = 1.618;
                            const spiralAngle = angle + (layer * goldenRatio * 10);
                            
                            const x = centerX + Math.cos(spiralAngle * Math.PI / 180) * layerRadius;
                            const y = centerY + Math.sin(spiralAngle * Math.PI / 180) * layerRadius;
                            
                            if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: ['#ff00ff', '#00ffff', '#ffff00', '#ff8000'][layer % 4],
                                    type: 'spectrum'
                                });
                            }
                        }
                    }
                }
            }
            
            generateTranscendentScene(variation = 0) {
                // Cosmic consciousness patterns
                const centerX = Math.floor(this.gridWidth / 2);
                const centerY = Math.floor(this.gridHeight / 2);
                
                // Central consciousness core
                for (let radius = 1; radius <= 8; radius++) {
                    for (let angle = 0; angle < 360; angle += 12) {
                        const x = centerX + Math.cos(angle * Math.PI / 180) * radius;
                        const y = centerY + Math.sin(angle * Math.PI / 180) * radius;
                        
                        if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                            this.setPixel(Math.floor(x), Math.floor(y), {
                                color: '#ffffff',
                                type: 'nova'
                            });
                        }
                    }
                }
                
                // Infinite patterns
                for (let i = 0; i < 300; i++) {
                    const x = Math.floor(Math.random() * this.gridWidth);
                    const y = Math.floor(Math.random() * this.gridHeight);
                    this.setPixel(x, y, {
                        color: ['#ff0080', '#8000ff', '#0080ff', '#00ff80', '#ff8000'][Math.floor(Math.random() * 5)],
                        type: 'cascade'
                    });
                }
            }
            
            generateAbstractScene() {
                // Completely abstract scenes
                for (let i = 0; i < 200; i++) {
                    const x = Math.floor(Math.random() * this.gridWidth);
                    const y = Math.floor(Math.random() * this.gridHeight);
                    this.setPixel(x, y, {
                        color: ['#ff0080', '#8000ff', '#0080ff', '#00ff80', '#ff8000'][Math.floor(Math.random() * 5)],
                        type: ['quantum', 'temporal', 'spectrum', 'cascade'][Math.floor(Math.random() * 4)]
                    });
                }
            }
            
            addCosmicEvent() {
                // Random cosmic event overlays
                const events = [
                    () => {
                        // Cosmic ray
                        const direction = Math.random() * Math.PI * 2;
                        for (let i = 0; i < Math.max(this.gridWidth, this.gridHeight); i += 3) {
                            const x = Math.cos(direction) * i;
                            const y = Math.sin(direction) * i;
                            
                            if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                this.setPixel(Math.floor(x), Math.floor(y), {
                                    color: '#ffffff',
                                    type: 'lightning'
                                });
                            }
                        }
                    },
                    () => {
                        // Dimensional portal
                        const portalX = Math.floor(Math.random() * this.gridWidth);
                        const portalY = Math.floor(Math.random() * this.gridHeight);
                        
                        for (let radius = 1; radius <= 12; radius++) {
                            for (let angle = 0; angle < 360; angle += 30) {
                                const x = portalX + Math.cos(angle * Math.PI / 180) * radius;
                                const y = portalY + Math.sin(angle * Math.PI / 180) * radius;
                                
                                if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                                    this.setPixel(Math.floor(x), Math.floor(y), {
                                        color: radius < 4 ? '#ff00ff' : '#8800ff',
                                        type: 'vortex'
                                    });
                                }
                            }
                        }
                    }
                ];
                
                const randomEvent = events[Math.floor(Math.random() * events.length)];
                randomEvent();
            }
            
            drawProbabilityLine(x1, y1, x2, y2) {
                const distance = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                const steps = Math.floor(distance);
                
                for (let step = 0; step <= steps; step++) {
                    if (Math.random() > 0.7) {
                        const t = step / steps;
                        const x = x1 + t * (x2 - x1);
                        const y = y1 + t * (y2 - y1);
                        
                        if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                            this.setPixel(Math.floor(x), Math.floor(y), {
                                color: ['#003311', '#001133', '#110033'][Math.floor(Math.random() * 3)],
                                type: 'phantom'
                            });
                        }
                    }
                }
            }
            
            drawLine(x1, y1, x2, y2, color) {
                const distance = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                const steps = Math.floor(distance);
                
                for (let step = 0; step <= steps; step++) {
                    const t = step / steps;
                    const x = x1 + t * (x2 - x1);
                    const y = y1 + t * (y2 - y1);
                    
                    if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                        this.setPixel(Math.floor(x), Math.floor(y), {
                            color: color,
                            type: 'particle'
                        });
                    }
                }
            }
            
            updateNarration() {
                // Get current chapter info
                let sceneCount = 0;
                let currentChapter = null;
                
                for (const chapter of this.chapters) {
                    if (this.currentScene < sceneCount + chapter.scenes) {
                        currentChapter = chapter;
                        break;
                    }
                    sceneCount += chapter.scenes;
                }
                
                if (!currentChapter) return;
                
                // Generate completely unique narrative
                const sceneNumberInChapter = this.currentScene % currentChapter.scenes;
                const narrative = this.generateProceduralNarrative(currentChapter.theme, sceneNumberInChapter);
                
                const narrationElement = document.getElementById('narrationText');
                narrationElement.classList.remove('active');
                
                setTimeout(() => {
                    narrationElement.textContent = narrative;
                    narrationElement.classList.add('active');
                }, 500);
                
                console.log(`üìñ Generated unique narrative for chapter: ${currentChapter.title}`);
            }
            
            setPixel(x, y, pixelData) {
                if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
                    this.pixels[y][x] = pixelData;
                }
            }
            
            clearCanvas() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.pixels = Array(this.gridHeight).fill().map(() => 
                    Array(this.gridWidth).fill({ color: '#000000', type: 'void' })
                );
            }
            
            renderCanvas() {
                this.clearCanvas();
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        const pixel = this.pixels[y][x];
                        if (pixel.color !== '#000000') {
                            this.ctx.fillStyle = pixel.color;
                            this.ctx.fillRect(
                                x * this.pixelSize,
                                y * this.pixelSize,
                                this.pixelSize,
                                this.pixelSize
                            );
                        }
                    }
                }
            }
            
            getRandomColor(palette = null) {
                if (palette) {
                    return palette[Math.floor(Math.random() * palette.length)];
                }
                
                const colors = ['#ff0080', '#8000ff', '#0080ff', '#00ff80', '#ff8000', '#ffff00', '#ff4040', '#40ff40', '#4040ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            endStory() {
                this.isPlaying = false;
                
                // Generate unique ending message
                const endings = [
                    "The cosmic journey continues... Create your own pixel universe!",
                    "Your unique cosmic story has been written in pixels and starlight...",
                    "The universe dreams through your creativity... What will you create next?",
                    "From quantum void to infinite art... The cycle begins anew...",
                    "Every pixel carries the memory of this cosmic dance...",
                    "The storyteller rests, but the cosmos never sleeps...",
                    "Your journey through the pixelverse is complete... Until next time...",
                    "Reality bends to imagination... Go forth and create worlds!"
                ];
                
                const randomEnding = endings[Math.floor(Math.random() * endings.length)];
                
                document.getElementById('narrationText').textContent = randomEnding;
                document.getElementById('narrationText').classList.add('active');
                
                console.log(`üåå Completed unique cosmic journey with ${this.chapters.length} chapters`);
                
                setTimeout(() => {
                    this.exitStory();
                }, 5000);
            }
        }
        
        // Initialize the storyteller when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PixelStoryteller();
        });
    </script>
</body>
</html>
